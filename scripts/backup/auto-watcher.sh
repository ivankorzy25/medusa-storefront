#!/bin/bash

# Auto-Watcher para Backups AutomÃ¡ticos del Storefront
# Monitorea cambios en archivos del frontend y hace backup automÃ¡tico

set -e

# Colores
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BLUE}  Medusa Storefront Auto-Backup Watcher${NC}"
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "${GREEN}ðŸ‘ï¸  Monitoreando cambios en el storefront...${NC}"
echo -e "${YELLOW}   Presiona Ctrl+C para detener${NC}"
echo ""

# Directorios y archivos a monitorear
WATCH_DIRS="src/ public/"
WATCH_FILES=".env.local next.config.ts package.json tsconfig.json"

# Tiempo mÃ­nimo entre backups (en segundos)
MIN_BACKUP_INTERVAL=60
LAST_BACKUP=0

# FunciÃ³n para hacer backup
do_backup() {
    CURRENT_TIME=$(date +%s)
    TIME_DIFF=$((CURRENT_TIME - LAST_BACKUP))

    if [ $TIME_DIFF -ge $MIN_BACKUP_INTERVAL ]; then
        echo ""
        echo -e "${BLUE}[$(date +'%H:%M:%S')] ðŸ”„ Cambios detectados, haciendo backup...${NC}"

        # Git add y commit
        git add .
        if ! git diff --cached --quiet; then
            TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
            git commit -m "ðŸ”„ Auto-backup Storefront: $TIMESTAMP

Changes detected by auto-watcher
Frontend changes - Generated by Medusa Auto-Backup System" > /dev/null 2>&1

            # Push a GitHub
            BRANCH=$(git branch --show-current)
            if git push origin "$BRANCH" --quiet > /dev/null 2>&1; then
                echo -e "${GREEN}   âœ“ Backup guardado en GitHub${NC}"
            else
                echo -e "${YELLOW}   âš ï¸  Backup local creado (push manual requerido)${NC}"
            fi
        fi

        LAST_BACKUP=$CURRENT_TIME
        echo -e "${GREEN}   âœ“ Backup completado${NC}"
        echo ""
    fi
}

# Detectar si fswatch estÃ¡ disponible
if command -v fswatch &> /dev/null; then
    # Usar fswatch (mÃ¡s eficiente)
    echo -e "${BLUE}   Usando fswatch para monitoreo${NC}"
    echo -e "${BLUE}   Monitoreando: src/, public/, .env.local, *.config.ts${NC}"
    echo ""

    # Monitorear mÃºltiples patrones
    fswatch -r \
        -e ".*" \
        -i "\\.tsx$" \
        -i "\\.ts$" \
        -i "\\.jsx$" \
        -i "\\.js$" \
        -i "\\.css$" \
        -i "\\.json$" \
        -i "\\.env" \
        -i "next\\.config" \
        -i "tailwind\\.config" \
        $WATCH_DIRS . | while read change; do
        # Ignorar node_modules y .next
        if [[ ! "$change" =~ node_modules ]] && [[ ! "$change" =~ \.next ]]; then
            do_backup
        fi
    done
else
    # Fallback: polling manual cada 30 segundos
    echo -e "${YELLOW}   Usando polling (instala fswatch para mejor rendimiento)${NC}"
    echo -e "${YELLOW}   brew install fswatch${NC}"
    echo ""

    PREVIOUS_HASH=""

    while true; do
        # Calcular hash de archivos relevantes (excluyendo node_modules y .next)
        CURRENT_HASH=$(find src/ public/ -type f 2>/dev/null | sort | xargs cat 2>/dev/null | md5 || echo "")

        # Agregar hash de archivos de configuraciÃ³n
        CONFIG_HASH=$(cat .env.local next.config.ts package.json tsconfig.json 2>/dev/null | md5 || echo "")
        CURRENT_HASH="${CURRENT_HASH}${CONFIG_HASH}"

        if [ -n "$CURRENT_HASH" ] && [ "$CURRENT_HASH" != "$PREVIOUS_HASH" ] && [ -n "$PREVIOUS_HASH" ]; then
            do_backup
        fi

        PREVIOUS_HASH="$CURRENT_HASH"
        sleep 30
    done
fi
